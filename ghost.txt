struct ghost_rom
{
	created:timestamp; // date created // used to have a unique ID
	name:string; // NFT name
	description:string; // NFT description
	imageURI:string; // NFT image // ipfs hash
	creator:address; // NFT original owner
	royalty:number; // commission %
	edition_id:number; // NFT series
	edition_number:number; // ID in specific NFT series
	infused_asset:string // asset symbol // array?
	infused_amount:number //  asset amount // array?
}

struct ghost_ram
{

}

struct ghost_contract // where can we fit all that?
{
	extended:string // json format?
	tokenURI:string // external API for extended metadata
}

struct mint_edition_info {
    edition_num: number; // edition series number
    edition_max: number; // max qty per NFT series
}

token ghost {
	global _owner: address;	// global storage for owner address
	global _contractAddress: address = $THIS_ADDRESS; // global storage for contract address
	global _mint_info:storage_map<number, mint_edition_info>; // global storage for nft editions

	property name: string = "GhostMarket";
	property symbol: string = "GHOST";

  property isTransferable: bool = true;
	property isFungible: bool = false;
	property isFinite: bool = false;
  property isDivisible: bool = false;
	property isFuel: bool = false;
	property isStakable: bool = false;
  property isFiat: bool = false;
	property isForeign: bool = false;
	property isBurnable: bool = true;
	property maxSupply: number = 0;
	property getOwner: address = _owner;

	import Runtime;
	import Token;

	constructor(owner:address)
	{
		_owner:= owner;
	}

	public updateOwner(from:address, newOwner:address)
	{
		// check is witness & is current owner
		Runtime.expect(Runtime.isWitness(_owner), "invalid witness");

		// check new owner address length
		Runtime.expect(newOwner.Length == 47 && newOwner.startsWith("P"), "invalid address format for newOwner");

		// set new owner
		_owner:= newOwner

	}

	public mintToken(name:string, description:string, imageURI:string, creator:address, royalty:number, edition_id:number, edition_max:number, infused_asset:string, infused_amount:number)
	{
		// check is witness
		Runtime.expect(Runtime.isWitness(_owner), "invalid witness");

		// validate name parameter
		Runtime.expect(name.Length >= 5 && name.Length <= 30, "invalid name length");

		// validate description parameter
		Runtime.expect(description.Length >= 10 && description.Length <= 350, "invalid description length");

		// validate imageURI parameter
		Runtime.expect(imageURI.Length >= 0, "invalid imageURI length");

		// validate creator parameter
		Runtime.expect(creator.Length == 47 && creator.startsWith("P"), "invalid address format for creator");

		// validate royalty parameter
		Runtime.expect(royalty >= 0 && royalty <= 100, "invalid number for royalties, it has to be between 0 and 100");

		// validate edition_id parameter
		Runtime.expect(edition_id > 0, "invalid number for edition_id, it has to be > 0");

		// validate edition_max parameter
		Runtime.expect(edition_max > 0, "invalid number for edition_max, it has to be > 0");

		// validate infused_amount parameter
		Runtime.expect(infused_amount >= 0, "invalid number for infused_amount, it has to be >= 0");

		// set local var based on struct
		local rom: ghost_rom := Struct.ghost_rom(Runtime.time, name, description, imageURI, creator, royalty, edition_id, infused_asset, infused_amount);

		// check mint maximum limit
		if (_mint_info.has(rom.edition_id))
		{
			local mi:mint_edition_info := _mint_info.get(rom.edition_id);
			mi.edition_number := mi.edition_number + 1;
			// check if series max reached
			Runtime.expect(this.checkMintLimit(mi.edition_number, mi.edition_max), "mint limit reached for this series")

			// update new mint number
			_mint_info.set(rom.edition_id, mi);
		}
		else
		{
			local mi:mint_edition_info = Struct.mint_edition_info(0, edition_max);

			// update new mint number
			_mint_info.set(rom.edition_id, mi);
		}

		// mint the NFT
		NFT.mint(_owner, creator, symbol, rom, "")

	}

	private checkMintLimit(edition_number:number, edition_max:number)
	{
		// check mint maximum limit
		if (edition_number < edition_max)
		{
			return false;
		}
		return true;
	}

	trigger onMint(from:address, to:address, symbol:string, amount:number)
	{
		if (rom.infused_amount > 0)
		{
			// transfer from owner to contract address
			Token.transfer(_owner, _contractAddress, rom.infused_asset, rom.infused_mount);
		}
	}

	trigger onBurn(from:address, to:address, symbol:string, amount:number)
	{
		if (rom.infused_amount > 0)
		{
			// transfer from contract address to owner
			Token.transfer(_contractAddress, _owner, rom.infused_asset, rom.infused_mount);
		}
	}

	/*trigger onSend(from:address, to:address, symbol:string, amount:number)
	{

	}*/

	/*trigger onReceive(from:address, to:address, symbol:string, amount:number)
	{

	}*/

	nft ghost_nft<ghost_rom, ghost_ram> {

		property created: timestamp {
			return rom.created;
		}

		property name: string {
			return rom.name;
		}

		property description: string {
			return rom.description;
		}

		property imageURI: string {
			return rom.imageURI;
		}

		property creator: address {
			return rom.creator;
		}

		property royalty: number {
			return rom.royalty;
		}

		property edition_id: number {
			return rom.edition_id;
		}

		property edition_number: number {
			return rom.edition_number;
		}

		property edition_max: number {
			return rom.edition_max;
		}

		property infused_asset: string {
			return rom.infused_asset;
		}

		property infused_amount: number {
			return rom.infused_amount;
		}

		property extended: string {
			return rom.extended;
		}

		property tokenURI: string {
			return rom.tokenURI;
		}

	}
}