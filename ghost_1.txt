/**
 * GHOSTMARKET PHANTASMA SMART CONTRACT
 */

 /*
   Everything stored on NFT ROM.
   Pros:
     + easier access
   Cons:
     - duplication and more storage used
 	   - rom max size should be 4x probably

 */

// ghost_rom struct
struct ghost_rom
{
  // ID of the NFT series
	edition_id:number;
 	// Number of the NFT in NFT series
	edition_number:number;
  // Date the NFT was created - used to have a unique ID
	created:timestamp;
  // Name of the NFT
	name:string;
  // Description of the NFT
	description:string;
  // Image of the NFT - IPFS hash
	imageURI:string;
  // Original owner of the NFT
	creator:address;
  // Commission (in %) for the royalties
	royalty:number;
  // Asset Symbol of the infused asset // array?
	infused_asset:string
  // Asset Amount of the infused asset // array?
	infused_amount:number
  // Token URI of the NFT for extended properties
	tokenURI:string;
}

// ghost_ram struct
struct ghost_ram
{

}

// series_info struct
struct series_info {
  // Number of the NFT in NFT series
  edition_number:number;
  // Edition Max the NFT series
  edition_max:number;
  // Name of the NFT
  name:string;
  // Description of the NFT
  description:string;
  // Image of the NFT - IPFS hash
  imageURI:string;
  // Original owner of the NFT
  creator:address;
  // Commission (in %) for the royalties
  royalty:number;
  // Asset Symbol of the infused asset // array?
  infused_asset:string
  // Asset Amount of the infused asset // array?
  infused_amount:number
  // Token URI of the NFT for extended properties
  tokenURI:string;
  // Extended properties
  extended:extended_properties;
}

// extended_properties struct
struct extended_properties
{

}

// infuse event struct
struct infuse_event_data {
	nftid:number;
	symbol:string;
  amount:number;
}

// mint infuse event
description infuse_event_mint {
  code(data:infuse_event_data): string {
    local result:string := "";
    result += infuse_event_data.nftid;
    result += " got infused with ";
    result += infuse_event_data.amount;
    result += " ";
    result += infuse_event_data.symbol;
    return result;
  }
}

// burn infuse event
description infuse_event_burn {
  code(data:infuse_event_data): string {
    local result:string := "";
    result += infuse_event_data.nftid;
    result += " got burned for ";
    result += infuse_event_data.amount;
    result += " ";
    result += infuse_event_data.symbol;
    return result;
  }
}

// ghost contract
token ghost {
  // global storage for owner address
	global _owner:address;
  // global storage for contract address
	global _contractAddress:address = $THIS_ADDRESS;
  // global storage for nft editions
	global _series_map:storage_map<number, series_info>;
  // global storage for contract pause
	global _paused:bool = false;

  // token name
	property name: string = "GhostMarket";
  // token symbol
	property symbol: string = "GHOST";
  // token version
  property version: string = "1.0";

  // token is transferable
  property isTransferable:bool = true;
  // token is not fungible
	property isFungible:bool = false;
  // token is burnable
	property isBurnable:bool = true;
  // token has no max supply
	property maxSupply:number = 0;
  // token current owner
	property getOwner:address = _owner;

  // infuse events
  event InfuseEventMint:infuse_event_data = infuse_event_mint;
  event InfuseEventBurn:infuse_event_data = infuse_event_burn;

  // libraries import
	import Runtime;
	import Token;

  // constructor with owner
	constructor(owner:address)
	{
		_owner:= owner;
	}

  /// @dev Update the current token contract owner address to another address.
  /// @param from - The address of the current owner.
  /// @param newOwner - The address of the new owner.
	public updateOwner(from:address, newOwner:address)
	{
		// check is witness & is current owner
		Runtime.expect(Runtime.isWitness(_owner), "invalid witness or not current owner");

		// check new owner address length
		Runtime.expect(newOwner.Length == 47 && newOwner.startsWith("P"), "invalid address format for newOwner");

		// set new owner
		_owner:= newOwner
	}

  /// @dev Update the current status of the token contract (paused / active).
  /// @param from - The address of the current owner.
  /// @param pause - The status of the contract (bool).
	public updatePause(from:address, pause:bool)
	{
		// check is witness & is current owner
		Runtime.expect(Runtime.isWitness(_owner), "invalid witness or not current owner");

		// set new status
		_pause:= pause
	}

  /// @dev Upgrade the current contract to a new one.
  /// @param from - The address of the current owner.
  /// @param script - The script of the new contract.
  public upgradeContract(from:address, script:bytes)
  {
    // check is witness & is current owner
    Runtime.expect(Runtime.isWitness(_owner), "invalid witness or not current owner");

    // upgrade contract
    Runtime.upgradeContract(contract, script)
  }

  /// @dev Mint a specific number of NFT on GhostMarket contract.
  /// @param edition_id - ID of the NFT series.
  /// @param edition_max - Edition Max the NFT series.
  /// @param num_of_nfts - Quantity of NFT to mint.
  /// @param name - Name of the NFT to mint.
  /// @param description - Description of the NFT to mint.
  /// @param imageURI - Image of the NFT - IPFS hash.
  /// @param creator - Original owner of the NFT.
  /// @param royalty - Commission (in %) for the royalties.
  /// @param infused_asset - Asset Symbol of the infused asset // array?.
  /// @param infused_amount - Asset Amount of the infused asset // array?.
  /// @param tokenURI - Token URI of the NFT for extended properties.
	public mintToken(edition_id:number, edition_max:number, num_of_nfts: number, name:string, description:string, imageURI:string, creator:address, royalty:number, infused_asset:string, infused_amount:number, tokenURI:string)
	{
		// check if contract is active
		Runtime.expect(!this.checkContractPaused(), "contract is currently paused");

		// check is witness
		Runtime.expect(Runtime.isWitness(creator), "invalid witness");

		// validate edition_id parameter
		Runtime.expect(edition_id > 0, "invalid number for edition_id, it has to be > 0");

		// validate edition_max parameter
		Runtime.expect(edition_max >= 0, "invalid number for edition_max, it has to be >= 0");

		// validate num_of_nfts parameter
		Runtime.expect(num_of_nfts > 0, "invalid number for edition_max, it has to be > 0");

		// validate name parameter
		Runtime.expect(name.Length >= 5 && name.Length <= 30, "invalid name length");

		// validate description parameter // reduce description length?
		Runtime.expect(description.Length >= 10 && description.Length <= 100, "invalid description length");

		// validate imageURI parameter
		Runtime.expect(imageURI.Length >= 0, "invalid imageURI length");

		// validate creator parameter
		Runtime.expect(creator.Length == 47 && creator.startsWith("P"), "invalid address format for creator");

		// validate royalty parameter
		Runtime.expect(royalty >= 0 && royalty <= 100, "invalid number for royalties, it has to be between 0 and 100");

    // validate infused_asset parameter // allow array?
		Runtime.expect(Runtime.tokenExists(infused_asset), "infused_asset is not a valid token");

		// validate infused_amount parameter // allow array?
		Runtime.expect(infused_amount >= 0, "invalid number for infused_amount, it has to be >= 0");

		// validate tokenURI parameter
		Runtime.expect(tokenURI.Length >= 0, "invalid tokenURI length");

		// check if series already exist
		if (!_series_map.has(edition_id))	// check proper way to check Map.has()
		{
      // create series if it does not exist yet
			this.createSeries(edition_id, edition_max, name, description, imageURI, creator, royalty, infused_asset, infused_amount, tokenURI)
		}
    // start minting nft
		this.mintSeries(edition_id, num_of_nfts)
	}

  /// @dev Create a new NFT series in GhostMarket contract.
  /// @param edition_id - ID of the NFT series.
  /// @param edition_max - Edition Max the NFT series.
  /// @param name - Name of the NFT to mint.
  /// @param description - Description of the NFT to mint.
  /// @param imageURI - Image of the NFT - IPFS hash.
  /// @param creator - Original owner of the NFT.
  /// @param royalty - Commission (in %) for the royalties.
  /// @param infused_asset - Asset Symbol of the infused asset // array?.
  /// @param infused_amount - Asset Amount of the infused asset // array?.
  /// @param tokenURI - Token URI of the NFT for extended properties.
	public createSeries(edition_id:number, edition_max:number, name:string, description:string, imageURI:string, creator:address, royalty:number, infused_asset:number, infused_amount:number, tokenURI:string)
	{
		// check if contract is active
		Runtime.expect(!this.checkContractPaused(), "contract is currently paused");

		// local var for series_info
		local info:series_info := Struct.series_info(0, edition_max, name, description, imageURI, creator, royalty, infused_asset, infused_amount, tokenURI);

		// check if series exists
		Runtime.expect(!_series_map.has(edition_id), "this series has already been created");	// check proper way to check Map.has()

		// create new series in storage
		_series_map.set(edition_id, series_info);
	}

  /// @dev Mint a specific number of NFT in a specific series on GhostMarket contract.
  /// @param edition_id - ID of the NFT series.
  /// @param num_of_nfts - Quantity of NFT to mint.
	public mintSeries(edition_id: number, num_of_nfts: number)
	{
		// check if contract is active
		Runtime.expect(!this.checkContractPaused(), "contract is currently paused");

		// local var for mint loop
		local index:number := 0;

		// local var for edition_id storage map
		local info:mint_edition_info := _series_map.get(rom.edition_id);

		// local var for ghost_rom storage map
		local rom: ghost_rom := Struct.ghost_rom(edition_id, info.edition_number, Runtime.time, info.name, info.description, info.imageURI, info.creator, info.royalty, info.infused_asset, info.infused_amount, info.tokenURI);

		// set new edition number count based on new nft created
		info.edition_number := info.edition_number + num_of_nfts;

		// check if series max reached
		Runtime.expect(this.checkMintLimitReached(mi.edition_number, mi.edition_max), "mint limit already exceeded for this series")

		// update new mint number
		_series_map.set(rom.edition_id, info);

		// mint all new nfts
		while (index < num_of_nfts) {
			rom.edition_number := rom.edition_number + 1
			NFT.mint(_owner, creator, symbol, rom, "");
			index := index + 1;
		}
	}

  /// @dev Internal method to check if mint limit was reached.
  /// @param edition_number - Number of the NFT in NFT series.
  /// @param edition_max - Edition Max the NFT series.
	private checkMintLimitReached(edition_number:number, edition_max:number)
	{
		// check if edition mint maximum limit reached
		if (edition_max > 0 && edition_number <= edition_max)
		{
			return false;
		}
		return true;
	}

  /// @dev Internal method to check if the contract is paused.
	private checkContractPaused()
	{
		// check if contract is paused
		if (_paused)
		{
			return true;
		}
		return false;
	}

  /// @dev onMint trigger.
  /// @param from - Address from.
  /// @param to - Address to.
  /// @param symbol - Symbol.
  /// @param amount - Amount.
  trigger onMint(from:address, to:address, symbol:string, amount:number)
	{
		// check if nft infused
		if (rom.infused_amount > 0)
		{
			// local var for get token
			local gettoken:= Runtime.getToken(rom.infused_asset);				// correct syntax?

			// local var for fungibility
			local fungible:bool = gettoken.Flags.HasFlag(TokenFlags.Fungible);	// correct syntax?

			// if fungible
			if (fungible)
			{
				// transfer ft from owner to contract
				Token.transfer(_owner, _contractAddress, rom.infused_asset, rom.infused_amount);
        emit InfuseEventMint(rom.nftid, rom.infused_asset, rom.infused_amount);
			}
			else
			{
				// transfer nft from owner to contract
				NFT.transfer(_owner, _contractAddress, rom.infused_asset, rom.infused_amount);
        emit InfuseEventMint(rom.nftid, rom.infused_asset, rom.infused_amount);
			}
		}
	}

  /// @dev onBurn trigger.
  /// @param from - Address from.
  /// @param to - Address to.
  /// @param symbol - Symbol.
  /// @param amount - Amount.
	trigger onBurn(from:address, to:address, symbol:string, amount:number)
	{
		// check if nft infused
		if (rom.infused_amount > 0)
		{
			// local var for get token
			local gettoken:= Runtime.getToken(rom.infused_asset);				// correct syntax?

			// local var for fungibility
			local fungible:bool = gettoken.Flags.HasFlag(TokenFlags.Fungible);	// correct syntax?

			// if fungible
			if (fungible)
			{
				// transfer ft from contract to owner
				Token.transfer(_contractAddress, _owner, rom.infused_asset, rom.infused_amount);
        emit InfuseEventBurn(rom.nftid, rom.infused_asset, rom.infused_amount);
			}
			else
			{
				// transfer nft from contract to owner
				NFT.transfer(_contractAddress, _owner, rom.infused_asset, rom.infused_amount);
        emit InfuseEventBurn(rom.nftid, rom.infused_asset, rom.infused_amount);
			}
		}
	}

  /// @dev ghost_nft struct.
	nft ghost_nft<ghost_rom, ghost_ram> {

		property edition_id: number {
			return rom.edition_id;
		}

		property edition_number: number {
			return rom.edition_number;
		}

		property edition_max: number {
			return rom.edition_max;
		}

		property created: timestamp {
			return rom.created;
		}

		property name: string {
			return rom.name;
		}

		property description: string {
			return rom.description;
		}

		property imageURI: string {
			return rom.imageURI;
		}

		property creator: address {
			return rom.creator;
		}

		property royalty: number {
			return rom.royalty;
		}

		property infused_asset: string {
			return rom.infused_asset;
		}

		property infused_amount: number {
			return rom.infused_amount;
		}

		property extended: string {
			return rom.extended;
		}

		property tokenURI: string {
			return rom.tokenURI;
		}
	}
}