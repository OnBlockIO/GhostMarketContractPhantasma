/**
 * GHOSTMARKET PHANTASMA SMART CONTRACT
 */

 /*
  Most data stored on contract storage. Can be done like this?
  Pros:
   + less storage used
   + low rom usage
   + extended properties could be stored on chain
  Cons:
   - slower for getting nft properties (access not optmized)

 */

// ghost_rom struct
struct ghost_rom
{
  // ID of the NFT series
  edition_id:number;
  // Number of the NFT in NFT series
  edition_number:number;
  // Date the NFT was created - used to have a unique ID
  created:timestamp;
}

// ghost_ram struct
struct ghost_ram
{

}

// series_info struct
struct series_info {
  // Number of the NFT in NFT series
  edition_number:number;
  // Edition Max the NFT series
  edition_max:number;
  // Name of the NFT
  name:string;
  // Description of the NFT
  description:string;
  // Image of the NFT - IPFS hash
  imageURI:string;
  // Original owner of the NFT
  creator:address;
  // Commission (in %) for the royalties
  royalty:number;
  // Asset Symbol of the infused asset // array?
  infused_asset:string
  // Asset Amount of the infused asset // array?
  infused_amount:number
  // Token URI of the NFT for extended properties
  tokenURI:string;
  // Extended properties
  extended:extended_properties;
}

// extended_properties struct
struct extended_properties
{

}

// infuse event struct
struct infuse_event_data {
	nftid:number;
	symbol:string;
  amount:number;
}

// mint infuse event
description infuse_event_mint {
  code(data:infuse_event_data): string {
    local result:string := "";
    result += infuse_event_data.nftid;
    result += " got infused with ";
    result += infuse_event_data.amount;
    result += " ";
    result += infuse_event_data.symbol;
    return result;
  }
}

// burn infuse event
description infuse_event_burn {
  code(data:infuse_event_data): string {
    local result:string := "";
    result += infuse_event_data.nftid;
    result += " got burned for ";
    result += infuse_event_data.amount;
    result += " ";
    result += infuse_event_data.symbol;
    return result;
  }
}

// ghost contract
token ghost {
  // global storage for owner address
  global _owner:address;
  // global storage for contract address
  global _contractAddress:address = $THIS_ADDRESS;
  // global storage for nft editions
  global _series_map:storage_map<number, series_info>;
  // global storage for contract pause
  global _paused:bool = false;
  // global storage for fees multiplier
  global _feesMultiplier:number = 10;

  // token name
  property name: string = "GhostMarket";
  // token symbol
  property symbol: string = "GHOST";
  // token version
  property version: string = "1.0";

  // token is transferable
  property isTransferable:bool = true;
  // token is not fungible
  property isFungible:bool = false;
  // token is burnable
  property isBurnable:bool = true;
  // token has no max supply
  property maxSupply:number = 0;
  // get current owner
	property getOwner:address = _owner;
  // get current fees multiplier
  property getFeesMultiplier:number = _feesMultiplier;

  // infuse events
  event InfuseEventMint:infuse_event_data = infuse_event_mint;
  event InfuseEventBurn:infuse_event_data = infuse_event_burn;

  // libraries import
  import Runtime;
  import Token;

  // constructor with owner
	constructor(owner:address)
	{
		_owner:= owner;
	}

  /// @dev Update the current token contract owner address to another address.
  /// @param from - The address of the current owner.
  /// @param newOwner - The address of the new owner.
	public updateOwner(from:address, newOwner:address)
	{
		// check is witness & is current owner
		Runtime.expect(Runtime.isWitness(_owner), "invalid witness or not current owner");

		// check new owner address length
		Runtime.expect(newOwner.Length == 47 && newOwner.startsWith("P"), "invalid address format for newOwner");

		// set new owner
		_owner:= newOwner
	}

  /// @dev Update the current status of the token contract (paused / active).
  /// @param from - The address of the current owner.
  /// @param pause - The status of the contract (bool).
	public updatePause(from:address, pause:bool)
	{
		// check is witness & is current owner
		Runtime.expect(Runtime.isWitness(_owner), "invalid witness or not current owner");

		// set new status
		_pause:= pause
	}

  /// @dev Upgrade the current contract to a new one.
  /// @param from - The address of the current owner.
  /// @param script - The script of the new contract.
  public upgradeContract(from:address, script:bytes)
  {
    // check is witness & is current owner
    Runtime.expect(Runtime.isWitness(_owner), "invalid witness or not current owner");

    // upgrade contract
    Runtime.upgradeContract(contract, script)
  }

  /// @dev Update the current service fees multiplier.
  /// @param from - The address of the current owner.
  /// @param feesMultiplier - Fees multiplier - number to multiply base fees.
  public updateFees(from:address, feesMultiplier:number)
  {
    // check is witness & is current owner
    Runtime.expect(Runtime.isWitness(_owner), "invalid witness or not current owner");

    // set fees
    _feesMultiplier:= feesMultiplier
  }

  /// @dev Mint a specific number of NFT on GhostMarket contract.
  /// @param edition_id - ID of the NFT series.
  /// @param edition_max - Edition Max the NFT series.
  /// @param num_of_nfts - Quantity of NFT to mint.
  /// @param name - Name of the NFT to mint.
  /// @param description - Description of the NFT to mint.
  /// @param imageURI - Image of the NFT - IPFS hash.
  /// @param creator - Original owner of the NFT.
  /// @param royalty - Commission (in %) for the royalties.
  /// @param infused_asset - Asset Symbol of the infused asset // array?.
  /// @param infused_amount - Asset Amount of the infused asset // array?.
  /// @param tokenURI - Token URI of the NFT.
  /// @param extended - Extended properties of the NFT.
	public mintToken(edition_id:number, edition_max:number, num_of_nfts: number, name:string, description:string, imageURI:string, creator:address, royalty:number, infused_asset:string, infused_amount:number, tokenURI:string, extended:string)
	{
    // check if contract is active
    Runtime.expect(!this.checkContractPaused(), "contract is currently paused");

		// check is witness
		Runtime.expect(Runtime.isWitness(creator), "invalid witness");

    // check if enough for transfer fees and burn fees
    local symbolFees:string := "KCAL";
    local serviceFees:number := _feesMultiplier * feesCostBase(num_of_nfts);
    Runtime.expect(Token.getBalance(creator, symbolFees) > serviceFees, "not enough fees to pay for this mint transaction")

		// validate edition_id parameter
		Runtime.expect(edition_id > 0, "invalid number for edition_id, it has to be > 0");

		// validate edition_max parameter
		Runtime.expect(edition_max >= 0, "invalid number for edition_max, it has to be >= 0");

		// validate num_of_nfts parameter
		Runtime.expect(num_of_nfts > 0, "invalid number for edition_max, it has to be > 0");

		// validate name parameter
		Runtime.expect(name.Length >= 5 && name.Length <= 30, "invalid name length");

		// validate description parameter // reduce description length?
		Runtime.expect(description.Length >= 10 && description.Length <= 100, "invalid description length");

		// validate imageURI parameter
		Runtime.expect(imageURI.Length >= 0, "invalid imageURI length");

		// validate creator parameter
		Runtime.expect(creator.Length == 47 && creator.startsWith("P"), "invalid address format for creator");

		// validate royalty parameter
		Runtime.expect(royalty >= 0 && royalty <= 100, "invalid number for royalties, it has to be between 0 and 100");

    // validate infused_asset parameter // allow array?
		Runtime.expect(Runtime.tokenExists(infused_asset), "infused_asset is not a valid token");

		// validate infused_amount parameter // allow array?
		Runtime.expect(infused_amount >= 0, "invalid number for infused_amount, it has to be >= 0");

		// validate tokenURI parameter
		Runtime.expect(tokenURI.Length >= 0, "invalid tokenURI length");

    // validate extended parameter
    Runtime.expect(extended.Length >= 0, "invalid extended length");

		// check if series already exist
		if (!_series_map.has(edition_id))	// check proper way to check Map.has()
		{
      // create series if it does not exist yet
			this.createSeries(edition_id, edition_max, name, description, imageURI, creator, royalty, infused_asset, infused_amount, tokenURI, extended)
		}
    // start minting nft
		this.mintSeries(creator, edition_id, num_of_nfts)
	}

  /// @dev Create a new NFT series in GhostMarket contract.
  /// @param edition_id - ID of the NFT series.
  /// @param edition_max - Edition Max the NFT series.
  /// @param name - Name of the NFT to mint.
  /// @param description - Description of the NFT to mint.
  /// @param imageURI - Image of the NFT - IPFS hash.
  /// @param creator - Original owner of the NFT.
  /// @param royalty - Commission (in %) for the royalties.
  /// @param infused_asset - Asset Symbol of the infused asset // array?.
  /// @param infused_amount - Asset Amount of the infused asset // array?.
  /// @param tokenURI - Token URI of the NFT.
  /// @param extended - Extended properties of the NFT.
	public createSeries(edition_id:number, edition_max:number, name:string, description:string, imageURI:string, creator:address, royalty:number, infused_asset:number, infused_amount:number, tokenURI:string, extended:string)
	{
    // check if contract is active
    Runtime.expect(!this.checkContractPaused(), "contract is currently paused");

		// local var for series_info
		local info:series_info := Struct.series_info(0, edition_max, name, description, imageURI, creator, royalty, infused_asset, infused_amount, tokenURI, extended);

		// check if series exists
		Runtime.expect(!_series_map.has(edition_id), "this series has already been created");	// check proper way to check Map.has()

		// create new series in storage
		_series_map.set(edition_id, series_info);
	}

  /// @dev Mint a specific number of NFT in a specific series on GhostMarket contract.
  /// @param edition_id - Address of the NFT series creator - minting on a series is restricted to this address.
  /// @param edition_id - ID of the NFT series.
  /// @param num_of_nfts - Quantity of NFT to mint.
	public mintSeries(creator:address, edition_id: number, num_of_nfts: number)
	{
    // check if contract is active
    Runtime.expect(!this.checkContractPaused(), "contract is currently paused");

    // check is witness
    Runtime.expect(Runtime.isWitness(creator), "invalid witness");

		// local var for mint loop
		local index:number := 0;

		// local var for edition_id storage map
		local info:mint_edition_info := _series_map.get(rom.edition_id);

		// local var for ghost_rom storage map
		local rom: ghost_rom := Struct.ghost_rom(edition_id, info.edition_number, Runtime.time);

		// set new edition number count based on new nft created
		info.edition_number := info.edition_number + num_of_nfts;

		// check if series max reached
		Runtime.expect(this.checkMintLimitReached(mi.edition_number, mi.edition_max), "mint limit already exceeded for this series")

		// update new mint number
		_series_map.set(rom.edition_id, info);

		// mint all new nfts
		while (index < num_of_nfts) {
			rom.edition_number := rom.edition_number + 1
			NFT.mint(_owner, creator, symbol, rom, "");
			index := index + 1;
		}

    // transfer service fees & pay burn fees
    local symbolFees:string := "KCAL";
    Token.transfer(creator, addressFees, symbolFees, serviceFees);
    Token.burn(creator, symbolFees, burnFees);
	}

  /// @dev Internal method to check if mint limit was reached.
  /// @param edition_number - Number of the NFT in NFT series.
  /// @param edition_max - Edition Max the NFT series.
	private checkMintLimitReached(edition_number:number, edition_max:number):bool
	{
		// check if edition mint maximum limit reached
		if (edition_max > 0 && edition_number <= edition_max)
		{
			return false;
		}
		return true;
	}

  /// @dev Internal method to check if the contract is paused.
  private checkContractPaused():bool
  {
    // check if contract is paused
    if (_paused)
    {
      return true;
    }
    return false;
  }

  /// @dev Internal method to get base fees based on mint quantity
  /// @param num_of_nfts - Quantity of NFT to mint.
  private feesCostBase(num_of_nfts: number)
  {
    // check if contract is paused
    if (num_of_nfts < 10)
    {
      local feesCostBase:number := 1;
    }
    else if (num_of_nfts >= 10 && num_of_nfts < 40)
    {
      local feesCostBase:number := 2.5;
    }
    else if (num_of_nfts >= 40 && num_of_nfts < 70)
    {
      local feesCostBase:number := 5;
    }
    else
    {
      local feesCostBase:number := 10;
    }
    return feesCostBase;
  }

  /// @dev onMint trigger.
  /// @param from - Address from.
  /// @param to - Address to.
  /// @param symbol - Symbol.
  /// @param amount - Amount.
  trigger onMint(from:address, to:address, symbol:string, amount:number)
	{
		// check if nft infused
		if (rom.infused_amount > 0)
		{
			// local var for get token
			local gettoken:= Runtime.getToken(rom.infused_asset);				// correct syntax?

			// local var for fungibility
			local fungible:bool = gettoken.Flags.HasFlag(TokenFlags.Fungible);	// correct syntax?

			// if fungible
			if (fungible)
			{
				// transfer ft from owner to contract
				Token.transfer(_owner, _contractAddress, rom.infused_asset, rom.infused_amount);
        emit InfuseEventMint(rom.nftid, rom.infused_asset, rom.infused_amount);
			}
			else
			{
				// transfer nft from owner to contract
				NFT.transfer(_owner, _contractAddress, rom.infused_asset, rom.infused_amount);
        emit InfuseEventMint(rom.nftid, rom.infused_asset, rom.infused_amount);
			}
		}
	}

  /// @dev onBurn trigger.
  /// @param from - Address from.
  /// @param to - Address to.
  /// @param symbol - Symbol.
  /// @param amount - Amount.
	trigger onBurn(from:address, to:address, symbol:string, amount:number)
	{
		// check if nft infused
		if (rom.infused_amount > 0)
		{
			// local var for get token
			local gettoken:= Runtime.getToken(rom.infused_asset);				// correct syntax?

			// local var for fungibility
			local fungible:bool = gettoken.Flags.HasFlag(TokenFlags.Fungible);	// correct syntax?

			// if fungible
			if (fungible)
			{
				// transfer ft from contract to owner
				Token.transfer(_contractAddress, _owner, rom.infused_asset, rom.infused_amount);
        emit InfuseEventBurn(rom.nftid, rom.infused_asset, rom.infused_amount);
			}
			else
			{
				// transfer nft from contract to owner
				NFT.transfer(_contractAddress, _owner, rom.infused_asset, rom.infused_amount);
        emit InfuseEventBurn(rom.nftid, rom.infused_asset, rom.infused_amount);
			}
		}
	}

	nft ghost_nft<ghost_rom, ghost_ram> {

		property edition_id: number {
			return rom.edition_id;
		}

		property edition_number: number {
			return rom.edition_number;
		}

		property edition_max: number {
			return _series_map.get(rom.edition_id).edition_max;
		}

		property created: timestamp {
			return rom.created;
		}

    property name: string {
			return _series_map.get(rom.edition_id).name;
		}

		property description: string {
			return _series_map.get(rom.edition_id).description;
		}

		property imageURI: string {
			return _series_map.get(rom.edition_id).imageURI;
		}

    property creator: address {
			return _series_map.get(rom.edition_id).creator;
		}

		property royalty: number {
			return _series_map.get(rom.edition_id).royalty;
		}

    property infused_asset: string {
			return _series_map.get(rom.edition_id).infused_asset;
		}

		property infused_amount: number {
			return _series_map.get(rom.edition_id).infused_amount;
		}

    property extended: string {
			return _series_map.get(rom.edition_id).extended;
		}

		property tokenURI: string {
			return _series_map.get(rom.edition_id).tokenURI;
		}
	}
}