/**
 * GHOSTMARKET - PHANTASMA SMART CONTRACT
 */

// ghostRom struct
struct ghostRom
{
    // ID of the NFT series - number
    editionId:number;
    // Number of the NFT in NFT series - number
    editionNumber:number;
    // ???
    editionMax:number;
    // Date the NFT was created - used to have a unique ID - timestamp
    created:timestamp;
    // Name of the NFT - string
    name:string;
    // Description of the NFT - string
    description:string;
    // Image of the NFT - IPFS hash - string
    imageURI:string;
    // Original owner of the NFT - address
    creator:address;
    // Commission (in %) for the royalties - decimal<2>
    royalty:decimal<2>;
    // Token URI of the NFT for extended properties - string
    infoURI:string;
    // Extended properties - custom struct
    extended:struct;
}

// ghostRam struct
struct ghostRam
{

}

// seriesInfo struct
struct seriesInfo {
    // Number of the NFT in NFT series - number
    editionNumber:number;
    // Edition Max the NFT series - number
    editionMax:number;
    // Name of the NFT - string
    name:string;
    // Description of the NFT - string
    description:string;
    // Image of the NFT - IPFS hash - string
    imageURI:string;
    // Original owner of the NFT - address
    creator:address;
    // Commission (in %) for the royalties - decimal<2>
    royalty:decimal<2>;
    // Token URI of the NFT for extended properties - string
    infoURI:string;
    // Extended properties - custom struct
    extended:struct;
}

// extended struct
struct extended
{
    // attribute1 - string
    attribute1:string;
    // attribute2 - string
    attribute1:string;
}

// ghost contract
token GHOST {
    // global storage for owner address
    global _addressOwner:address;
    // global storage for contract address
    global _addressContract:address;
    // global storage for nft edition
    global _seriesMap:storage_map<number, seriesInfo>;
    // global storage for contract pause
    global _contractPaused:bool;
    // global storage for fees multiplier
    global _feesMultiplier:number;
	// global storage for fees symbol
    global _feesSymbol:string;
    // global storage for fees threshold1
    global _feesThreshold1:number;
    // global storage for fees threshold2
    global _feesThreshold2:number;
    // global storage for fees threshold3
    global _feesThreshold3:number;
	// global storage for fees address
	global _feesAddress:address;

    // token name
    property name:string = "GhostMarket NFT";
    // token version
    property version:string = "1.0";
    // token is transferable
    property isTransferable:bool = true;
    // token is not fungible
    property isFungible:bool = false;
    // token is burnable
    property isBurnable:bool = true;
    // token has no max supply
    property maxSupply:number = 0;
    // token owner address
    property addressOwner:address = _addressOwner;
    // token fees multiplier
    property feesMultiplier:number = _feesMultiplier;
	// token fees symbol
    property feesSymbol:string = _feesSymbol;
    // token fees threshold1
    property feesThreshold1:number = _feesThreshold1;
    // token fees threshold2
    property feesThreshold2:number = _feesThreshold2;
    // token fees threshold2
    property feesThreshold3:number = _feesThreshold3;
	// token fees address
    property feesAddress:address = _feesAddress;

    // libraries import
    import Runtime;
    import Token;
	import Map;
	import NFT;
    import Time;

    // constructor with owner
    constructor(owner:address)
    {
        _addressOwner:= owner;
		_addressContract:= $THIS_ADDRESS;
		_contractPaused:= false;
		_feesMultiplier:= 1;
		_feesSymbol:= "KCAL";
		_feesThreshold1:= 10;
		_feesThreshold2:= 40;
		_feesThreshold3:= 70;
		_feesAddress:= @P2KLzxq8cUi47URLZZYcLs54WPVYnknrHWVryUUUqhuhq5K; // ghostmarket
    }

	/// @dev Internal method to check if mint limit was reached.
    /// @param editionNumber - Number of the NFT in NFT series - number
    /// @param editionMax - Edition Max the NFT series - number
    private checkMintLimitReached(editionNumber:number, editionMax:number):bool
    {
        // check if edition mint maximum limit reached
        if (editionMax > 0 and editionNumber <= editionMax)
        {
            return false;
        }
        return true;
    }

    /// @dev Internal method to check if the contract is paused.
    private checkContractPaused():bool
    {
        // check if contract is paused
        if (_contractPaused)
        {
            return true;
        }
        return false;
    }

    /// @dev Internal method to get base fees based on mint quantity
    /// @param numOfNfts - Quantity of NFT to mint - number
    private feesBase(numOfNfts:number):number
    {
		local feesBase:number;
    		// if < threshold 1
        if (numOfNfts < _feesThreshold1)
        {
            feesBase := 10 * _feesMultiplier;
        }
		else {
    		// if < threshold 2
			if (numOfNfts >= _feesThreshold1 and numOfNfts < _feesThreshold2)
			{
				feesBase:= 25 * _feesMultiplier;
			}
			else
			{
      			// if < threshold 3
				if (numOfNfts >= _feesThreshold2 and numOfNfts < _feesThreshold3)
				{
					feesBase := 50 * _feesMultiplier;
				}
        		// if > threshold 3
				else
				{
					feesBase := 100 * _feesMultiplier;
				}
			}
		}
        return feesBase;
    }

	/// @dev Internal method to check if enough fees based on mint quantity
    /// @param numOfNfts - Quantity of NFT to mint - number
	/// @param creator - Address trying to mint - address
    private checkFees(numOfNfts:number, creator:address)
    {
		local decimalsFees:number := 10 ^ Token.getDecimals(_feesSymbol);
		local feesBaseResult:number := this.feesBase(numOfNfts);
		local serviceFees:number := _feesMultiplier * feesBaseResult;
		Runtime.expect(Token.getBalance(creator, _feesSymbol) > serviceFees * decimalsFees * 10 ^ Token.getDecimals(_feesSymbol), "not enough fees to pay for this mint transaction");
    }

	/// @dev Internal method to transfer fees based on mint quantity
    /// @param numOfNfts - Quantity of NFT to mint - number
	/// @param creator - Address trying to mint - address
    private payFees(numOfNfts:number, creator:address)
    {
		local decimalsFees:number := 10 ^ Token.getDecimals(_feesSymbol);
		local feesBaseResult:number := this.feesBase(numOfNfts);
		local serviceFees:number := _feesMultiplier * feesBaseResult;
		Token.transfer(creator, _feesAddress, _feesSymbol, serviceFees * 10 ^ decimalsFees);
		Token.burn(creator, _feesSymbol, serviceFees);
    }

    /// @dev Update the current token contract owner address to another address.
    /// @param newOwner - The address of the new owner - address
    public updateOwner(newOwner:address)
    {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // set new owner
        _addressOwner:= newOwner;
    }

    /// @dev Update the current status of the token contract (paused / active).
    /// @param pause - The status of the contract (bool) - bool
    public updatePause(pause:bool)
    {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // set new status
        _contractPaused:= pause;
    }

    /// @dev Update the current fees multiplier.
    /// @param feesMultiplier - number to use to multiply base fees - number
    public updateFeesMultiplier(feesMultiplier:number)
    {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // check feesMultiplier parameter
        Runtime.expect(feesMultiplier > 0, "invalid number for feesMultiplier. Received " + feesMultiplier + ", while it should be > 0");

        // set fees
        _feesMultiplier:= feesMultiplier;
    }

	/// @dev Update the current asset used for fees.
    /// @param feesSymbol - asset to use to pay fees - string
    public updateFeesSymbol(feesSymbol:string)
    {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // check feesSymbol parameter
		Runtime.expect(Token.exists(feesSymbol), "feesSymbol is not a valid token");

        // set fees
        _feesSymbol:= feesSymbol;
    }

    /// @dev Update the current fees thresholds.
    /// @param feesThresholdIndex - Index of the threshold (1,2 or 3) - number
    /// @param feesThresholdValue - Value of the specific threshold - number
    public updateFeesThresholds(feesThresholdIndex:number, feesThresholdValue:number)
    {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // check feesThresholdIndex parameter
        Runtime.expect(feesThresholdIndex <= 3, "invalid number for feesThresholdIndex, it has to be 1,2 or 3");
        Runtime.expect(feesThresholdIndex > 0, "invalid number for feesThresholdIndex, it has to be 1,2 or 3");

        // check feesThresholdValue parameter
        Runtime.expect(feesThresholdValue > 0, "invalid number for feesThresholdValue, it has to be > 0");

        // set fees
        if (feesThresholdIndex == 1)
        {
            _feesThreshold1:= feesThresholdValue;
        }
        if (feesThresholdIndex == 2)
        {
            _feesThreshold2:= feesThresholdValue;
        }
        if (feesThresholdIndex == 3)
        {
            _feesThreshold3:= feesThresholdValue;
        }
    }

	/// @dev Update the current fees address.
    /// @param feesAddress - address used to collect fees - address
    public updateFeesAddress(feesAddress:address)
    {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // set fees
        _feesAddress:= feesAddress;
    }

	/// @dev Create a new NFT series in GhostMarket contract.
    /// @param editionId - ID of the NFT series - number
    /// @param editionMax - Edition Max the NFT series - number
    /// @param name - Name of the NFT to mint - string
    /// @param description - Description of the NFT to mint - description
    /// @param imageURI - Image of the NFT - IPFS hash - string
    /// @param creator - Original owner of the NFT - address
    /// @param royalty - Commission (in %) for the royalties - decimal<2>
    /// @param infoURI - Token URI of the NFT - string
    /// @param extended - Extended properties of the NFT - custom struct
    /// @param mintTicker - Ticker token on which to mint the NFT - string
                // CreateSeries(StorageContext storage, IToken token, BigInteger seriesID, BigInteger maxSupply, byte[] script, ContractInterface abi)
                // Runtime.Expect(mintID < seriesSupply, $"{symbol} series {seriesID} reached max supply already");
                // Runtime.Expect(mintID < series.MaxSupply, $"{symbol} series {seriesID} reached max supply already");
                // CreateTokenSeries(symbol, from, seriesID, maxSupply, script, abi);
    public createSeries(editionId:number, editionMax:number, name:string, description:string, imageURI:string, creator:address, royalty:decimal<2>, infoURI:string, extended:struct, mintTicker:string)
    {
        // check if contract is active
        Runtime.expect(this.checkContractPaused() != true, "GhostMarket smart contract is currently paused");

        // check is witness
        Runtime.expect(Runtime.isWitness(creator), "invalid witness");

        // check allow gas dapp transaction fees
        Runtime.expect(Runtime.gasTarget() == $THIS_ADDRESS, "invalid dapp destination address transaction fees");

        // check editionId parameter
        Runtime.expect(editionId > 0, "invalid number for editionId, it has to be > 0");

        // check editionMax parameter
        Runtime.expect(editionMax >= 0, "invalid number for editionMax, it has to be >= 0");

        // check name parameter
		Runtime.expect(name.length() >= 3, "invalid name length");
		Runtime.expect(name.length() <= 30, "invalid name length");

        // check description parameter // reduce description length?
		Runtime.expect(description.length() >= 10, "invalid description length");
		Runtime.expect(description.length() <= 100, "invalid description length");

        // check imageURI parameter
        Runtime.expect(imageURI.length() >= 0, "invalid imageURI length");

        // check royalty parameter
        Runtime.expect(royalty >= 0.00 and royalty <= 100.00, "invalid number for royalties, it has to be between 0.00 and 100.00");

        // check infoURI parameter
        Runtime.expect(infoURI.length() >= 0, "invalid infoURI length");

        // check extended parameter
        // Runtime.expect(extended.attribute1.length() >= 0, "invalid extended attribute1 length");

        // check mintTicker parameter
		Runtime.expect(Token.exists(mintTicker), "mintTicker is not a valid token");

        // set local var for seriesInfo
        // local info:seriesInfo := Struct.seriesInfo(0, editionMax, name, description, imageURI, creator, royalty, infoURI, extended);

        // check if series exists
        // Runtime.expect(_seriesMap.has(editionId) == false, "this series has already been created");

        // create new series in storage
        // _seriesMap.set(editionId, info);
    }

	/// @dev Mint a specific number of NFT in a specific series on GhostMarket contract.
    /// @param editionId - Address of the NFT series creator - minting on a series is restricted to this address - address
    /// @param editionId - ID of the NFT series - number
    /// @param numOfNfts - Quantity of NFT to mint - number
    /// @param mintTicker - Ticker token on which to mint the NFT - string
    public mintSeries(creator:address, editionId:number, numOfNfts:number, mintTicker:string)
    {
        // check if contract is active
        Runtime.expect(this.checkContractPaused() != true, "GhostMarket smart contract is currently paused");

        // check is witness
        Runtime.expect(Runtime.isWitness(creator), "invalid witness");

        // check allow gas dapp transaction fees
        Runtime.expect(Runtime.gasTarget() == $THIS_ADDRESS, "invalid dapp destination address transaction fees");

        // check editionId parameter
        Runtime.expect(editionId > 0, "invalid number for editionId, it has to be > 0");

        // check numOfNfts parameter
        Runtime.expect(numOfNfts > 0, "invalid number for numOfNfts, it has to be > 0");

        // check mintTicker parameter
		Runtime.expect(Token.exists(mintTicker), "mintTicker is not a valid token");

        // set local var for mint loop
        // local index:number := 0;

        // set local var for editionId storage map
        // local info:seriesInfo := _seriesMap.get(rom.editionId); // how to access rom?

        // set local var for ghostRom storage map
        // local rom:ghostRom := Struct.ghostRom(editionId, info.editionNumber, Time.now, info.name, info.description, info.imageURI, info.creator, info.royalty, info.infoURI, info.extended); // how to access rom?

        // set new edition number count based on new nft created
        // info.editionNumber := info.editionNumber + numOfNfts;  // how to access rom?

        // check if series max reached
        // Runtime.expect(this.checkMintLimitReached(info.editionNumber, info.editionMax), "mint limit already exceeded for this series") / how to access rom?

        // set new mint number
        // _seriesMap.set(rom.editionId, info); // how to access rom?

        // mint all new nfts
        // while (index < numOfNfts) {
            // rom.editionNumber := rom.editionNumber + 1
            // NFT.mint(_addressOwner, creator, mintTicker, rom, "");
            // index := index + 1;
        // }

        // if feesMultipler > 0, pay service fees and pay burn fees
        // if (_feesMultiplier > 0)
        // {
			// this.payFees(numOfNfts, creator);
        // }
    }

    /// @dev Mint a specific number of NFT on GhostMarket contract.
    /// @param editionId - ID of the NFT series - number
    /// @param editionMax - Edition Max the NFT series - number
    /// @param numOfNfts - Quantity of NFT to mint - number
    /// @param name - Name of the NFT to mint - string
    /// @param description - Description of the NFT to mint - string
    /// @param imageURI - Image of the NFT - IPFS hash - string
    /// @param creator - Original owner of the NFT - address
    /// @param royalty - Commission (in %) for the royalties - decimal<2>
    /// @param infoURI - Token URI of the NFT - string
    /// @param extended - Extended properties of the NFT - custom struct
    /// @param mintTicker - Ticker token on which to mint the NFT - string
    /// @param lockedContent - NFT has locked content - bool
    /// @param hashLockedContent - NFT locked content hash - string
    public mintToken(editionId:number, editionMax:number, numOfNfts:number, name:string, description:string, imageURI:string, creator:address, royalty:decimal<2>, infoURI:string, extended:struct, mintTicker:string, hasLockedContent:bool, lockedContent:string)
    {
        // check if contract is active
        Runtime.expect(this.checkContractPaused() != true, "GhostMarket smart contract is currently paused");

        // check is witness
        Runtime.expect(Runtime.isWitness(creator), "invalid witness");

        // check allow gas dapp transaction fees
        Runtime.expect(Runtime.gasTarget() == $THIS_ADDRESS, "invalid dapp destination address transaction fees");

        // check editionId parameter
        Runtime.expect(editionId > 0, "invalid number for editionId, it has to be > 0");

        // check editionMax parameter
        Runtime.expect(editionMax >= 0, "invalid number for editionMax, it has to be >= 0");

        // check numOfNfts parameter
        Runtime.expect(numOfNfts > 0, "invalid number for numOfNfts, it has to be > 0");

        // if fees multiplier > 0, check if enough for transfer fees and burn fees
        if (_feesMultiplier > 0)
        {
			this.checkFees(numOfNfts, creator);
        }

        // check name parameter
		Runtime.expect(name.length() >= 3, "invalid name length");
		Runtime.expect(name.length() <= 30, "invalid name length");

        // check description parameter
		Runtime.expect(description.length() >= 10, "invalid name length");
		Runtime.expect(description.length() <= 100, "invalid name length");

        // check imageURI parameter
        Runtime.expect(imageURI.length() >= 0, "invalid imageURI length");

        // check royalty parameter
        Runtime.expect(royalty >= 0.00 and royalty <= 100.00, "invalid number for royalties, it has to be between 0.00 and 100.00");

        // check infoURI parameter
        Runtime.expect(infoURI.length() >= 0, "invalid infoURI length");

        // check extended parameter
        // Runtime.expect(extended.attribute1.length() >= 0, "invalid extended attribute1 length");

        // check mintTicker parameter
		Runtime.expect(Token.exists(mintTicker), "mintTicker is not a valid token");

        if (lockedContent)
        {
            // check hashLockedContent parameter
            Runtime.expect(hashLockedContent.length() >= 0, "invalid hashLockedContent length");
        }

        // check if series already exist // chg to native logic
        // if (_seriesMap.has(editionId) == false) // chg to native logic
        // {
            // create series if it does not exist yet // chg to native logic
            // this.createSeries(editionId, editionMax, name, description, imageURI, creator, royalty, infoURI, extended); // chg to native logic
        // }
        // start minting nft
        // this.mintSeries(creator, editionId, numOfNfts);
    }

    /// @dev onUpgrade trigger.
    /// @param from - Address from - address
	trigger onUpgrade(from:address) {
        // check is witness and is current owner
        Runtime.expect(from == _addressOwner, "must be owner");
		Runtime.expect(Runtime.isWitness(from), "invalid witness");
        return;
    }

    /// @dev ghostNft struct.
    nft ghostNft<ghostRom, ghostRam> {

        import Token;

        property editionId:number {
            return _ROM.editionId;
        }

        property editionNumber:number {
            return _ROM.editionNumber;
        }

        property editionMax:number {
            return _ROM.editionMax;
        }

        property created:timestamp {
            return _ROM.created;
        }

        property name:string {
            return _ROM.name;
        }

        property description:string {
            return _ROM.description;
        }

        property imageURI:string {
            return _ROM.imageURI;
        }

        property creator:address {
            return _ROM.creator;
        }

        property royalty:decimal<2> {
            return _ROM.royalty;
        }

        property extended:struct {
            return _ROM.extended;
        }

        property infoURI:string {
            return _ROM.infoURI;
        }
    }

}