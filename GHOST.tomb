/**
 * GHOSTMARKET - PHANTASMA SMART CONTRACT
 */

// ghostRom struct
struct ghostRom
{
    // Date the NFT was created - used to have a unique ID - timestamp
    created:timestamp;
    // Original owner of the NFT - address
    creator:address;
    // Commission (in %) for the royalties - decimal<2>
    royalty:decimal<2>;
    // Name of the NFT - string
    name:string;
    // Description of the NFT - string
    description:string;
    // Image of the NFT - IPFS hash - string
    imageURI:string;
    // Info URI of the NFT for extended properties - string
    infoURI:string;
    // Extended attribute1 type - string
    attributeType1:string;
    // Extended attribute1 value - string
    attributeValue1:string;
    // Extended attribute2 type - string
    attributeType2:string;
    // Extended attribute2 value - string
    attributeValue2:string;
    // Extended attribute3 type - string
    attributeType3:string;
    // Extended attribute3 value - string
    attributeValue3:string;
    // Extended attribute4 type - string
    attributeType4:string;
    // Extended attribute4 value - string
    attributeValue4:string;
}

// ghostRam struct
struct ghostRam
{

}

// ghost token contract
token GHOST {

    // global storage for owner address
    global _addressOwner:address;
    // global storage for contract address
    global _addressContract:address;
    // global storage for contract pause
    global _contractPaused:bool;
    // global storage for locked content
    global _lockedStorageMap: storage_map<number, string>;
    // global storage for fees multiplier
    global _feesMultiplier:number;
	// global storage for fees symbol
    global _feesSymbol:string;
    // global storage for fees threshold1
    global _feesThreshold1:number;
    // global storage for fees threshold2
    global _feesThreshold2:number;
    // global storage for fees threshold3
    global _feesThreshold3:number;
	// global storage for fees address
	global _feesAddress:address;
    // global storage for infuse multiplier
    global _infuseMultiplier:number;

    // token name
    property name:string = "GhostMarket NFT";
    // token version
    property version:string = "1.0";
    // token is transferable
    property isTransferable:bool = true;
    // token is not fungible
    property isFungible:bool = false;
    // token is burnable
    property isBurnable:bool = true;
    // token is finite
    property isFinite:bool = false;
    // token has no max supply
    property maxSupply:number = 0;
    // token owner address
    property addressOwner:address = _addressOwner;
    // token fees multiplier
    property feesMultiplier:number = _feesMultiplier;
	// token fees symbol
    property feesSymbol:string = _feesSymbol;
    // token fees threshold1
    property feesThreshold1:number = _feesThreshold1;
    // token fees threshold2
    property feesThreshold2:number = _feesThreshold2;
    // token fees threshold2
    property feesThreshold3:number = _feesThreshold3;
	// token fees address
    property feesAddress:address = _feesAddress;
    // token infuse multiplier
    property infuseMultiplier:number = _infuseMultiplier;

    /// ghostNft struct
    nft ghostNft<ghostRom, ghostRam> {

        import Token;

        property created:timestamp {
            return _ROM.created;
        }

        property creator:address {
            return _ROM.creator;
        }

        property royalty:decimal<2> {
            return _ROM.royalty;
        }

        property name:string {
            return _ROM.name;
        }

        property description:string {
            return _ROM.description;
        }

        property imageURI:string {
            return _ROM.imageURI;
        }

        property infoURI:string {
            return _ROM.infoURI;
        }

        property attributeType1:string {
            return _ROM.attributeType1;
        }

        property attributeValue1:string {
            return _ROM.attributeValue1;
        }

        property attributeType2:string {
            return _ROM.attributeType2;
        }

        property attributeValue2:string {
            return _ROM.attributeValue2;
        }

        property attributeType3:string {
            return _ROM.attributeType3;
        }

        property attributeValue3:string {
            return _ROM.attributeValue3;
        }

        property attributeType4:string {
            return _ROM.attributeType4;
        }

        property attributeValue4:string {
            return _ROM.attributeValue4;
        }

    }

    // libraries import
    import Runtime;
    import Token;
	import Map;
	import NFT;
    import Time;
    import UID;

    // constructor with owner
    constructor(owner:address)
    {
        _addressOwner:= owner;
        _addressContract:= $THIS_ADDRESS;
		_contractPaused:= false;
		_feesMultiplier:= 1;
		_feesSymbol:= "KCAL";
		_feesThreshold1:= 10;
		_feesThreshold2:= 40;
		_feesThreshold3:= 70;
		_feesAddress:= @P2KLzxq8cUi47URLZZYcLs54WPVYnknrHWVryUUUqhuhq5K; // ghostmarket
        _infuseMultiplier:= 1;
    }

    /// @dev Internal method to check if the contract is paused.
    private checkContractPaused():bool
    {
        // check if contract is paused
        if (_contractPaused)
        {
            return true;
        }
        return false;
    }

    /// @dev Internal method to return base fees based on mint quantity
    /// @param numOfNfts - Quantity of NFT to mint - number
    private feesBase(numOfNfts:number):number
    {
		local feesBase:number;
        // if < threshold 1
        if (numOfNfts < _feesThreshold1)
        {
            feesBase := 10 * _feesMultiplier;
        }
		else {
    		// if < threshold 2
			if (numOfNfts >= _feesThreshold1 and numOfNfts < _feesThreshold2)
			{
				feesBase:= 25 * _feesMultiplier;
			}
			else
			{
      			// if < threshold 3
				if (numOfNfts >= _feesThreshold2 and numOfNfts < _feesThreshold3)
				{
					feesBase := 50 * _feesMultiplier;
				}
        		// if > threshold 3
				else
				{
					feesBase := 100 * _feesMultiplier;
				}
			}
		}
        return feesBase;
    }

	/// @dev Internal method to check if enough fees based on mint quantity
    /// @param numOfNfts - Quantity of NFT to mint - number
	/// @param creator - Address trying to mint - address
    private checkFees(numOfNfts:number, creator:address)
    {
        local feesBalance:number := Token.getBalance(creator, _feesSymbol);
        local feesRequired:number := this.feesBase(numOfNfts) * 10 ^ Token.getDecimals(_feesSymbol);
        local missingFees:number := feesBalance - feesRequired;
        // check required fees missing, if any
		Runtime.expect(missingFees > 0, "not enough fees to pay for this mint transaction, requires " + missingFees + " more " + _feesSymbol);
    }

	/// @dev Internal method to transfer fees based on mint quantity
    /// @param numOfNfts - Quantity of NFT to mint - number
	/// @param creator - Address trying to mint - address
    private payFees(numOfNfts:number, creator:address)
    {
        // calculate fees base
		local feesBaseResult:number := this.feesBase(numOfNfts);
        // calculate infuse
        local infuseAmount:number := _infuseMultiplier * 10 ^ Token.getDecimals(_feesSymbol);
        // calculate fees minus infuse
        local feesTransfer:number := (feesBaseResult * 10 ^ Token.getDecimals(_feesSymbol)) - infuseAmount;
        // calculate fees burn
        local feesBurn:number := feesBaseResult * 10 ^ Token.getDecimals(_feesSymbol);
        // fees payment
        Token.transfer(creator, _feesAddress, _feesSymbol, feesTransfer);
        // fees burn
		Token.burn(creator, _feesSymbol, feesBurn);
    }

    /// @dev Create a new NFT series.
    /// @param editionId - ID of the NFT series - number
    /// @param editionMax - Edition Max the NFT series - number
    /// @param editionMode - Edition Mode the NFT series, 1 for duplicate, 2 for unique - number
    /// @param creator - Original owner of the NFT - address
    /// @param mintTicker - Ticker token on which to mint the NFT - string
    private createSeries(editionId:number, editionMax:number, editionMode:number, creator:address, mintTicker:string)
    {
        // check if contract is active
        Runtime.expect(this.checkContractPaused() != true, "GhostMarket smart contract is currently paused");

        // check is witness
        Runtime.expect(Runtime.isWitness(creator), "invalid witness");

        // check allow gas dapp transaction fees
        Runtime.expect(Runtime.gasTarget() == _addressContract, "invalid address for dapp transaction fees in AllowGas, it should be " + _addressContract);

        // check editionId parameter
        Runtime.expect(editionId > 0, "invalid number for editionId, it should be > 0, received " + editionId);

        // check editionMax parameter
        Runtime.expect(editionMax >= 0, "invalid number for editionMax, it should be >= 0, received " + editionMax);

        // check editionMode parameter
        Runtime.expect(editionMode > 0, "invalid number for editionMode, it should be > 0, received " + editionMode);

        // check mintTicker parameter
		Runtime.expect(Token.exists(mintTicker), "invalid token for mintTicker, received " + mintTicker);

        // check mintTicker is not fungible
        local flags:TokenFlags := Token.getFlags(mintTicker);
        Runtime.expect(flags.isSet(TokenFlags.Fungible) == false, "invalid fungible flag for " + mintTicker);

        // TokenSeries mode
        if (editionMode == 1)
        {
            // create series duplicated
            // NFT.createSeries(creator, mintTicker, editionId, editionMax, TokenSeries.Duplicated, ghostNft);
        }
        else
        {
            // create series unique
            // NFT.createSeries(creator, mintTicker, editionId, editionMax, TokenSeries.Unique, ghostNft);
        }

    }

    /// @dev Mint a specific number of NFT in a series with unique content.
    /// @param editionId - ID of the NFT series - number
    /// @param creator - Original owner of the NFT - address
    /// @param royalty - Commission (in %) for the royalties - decimal<2>
    /// @param mintTicker - Ticker token on which to mint the NFT - string
    /// @param numOfNfts - Quantity of NFT to mint - number
    /// @param name - Name of the NFT to mint - string
    /// @param description - Description of the NFT to mint - string
    /// @param imageURI - Image of the NFT - IPFS hash - string
    /// @param infoURI - Token URI of the NFT - string
    /// @param attributeType1 - Extended properties of the NFT - string
    /// @param attributeValue1 - Extended properties of the NFT - string
    /// @param attributeType2 - Extended properties of the NFT - string
    /// @param attributeValue2 - Extended properties of the NFT - string
    /// @param attributeType3 - Extended properties of the NFT - string
    /// @param attributeValue3 - Extended properties of the NFT - string
    /// @param attributeType4 - Extended properties of the NFT - string
    /// @param attributeValue4 - Extended properties of the NFT - string
    /// @param hasLockedContent - NFT has locked content - bool
    /// @param lockedContent - NFT locked content hash - string
    private mintSeries(editionId:number, creator:address, royalty:decimal<2>, mintTicker:string, numOfNfts:number, name:string, description:string, imageURI:string, attributeType1:string, attributeValue1:string, attributeType2:string, attributeValue2:string, attributeType3:string, attributeValue3:string, attributeType4:string, attributeValue4:string, hasLockedContent:bool, lockedContent:string)
    {
        // local var for loop mint
        local index:number := 0;

        // local var for infoURI
        local infoURI:string := "";

        // local var for rom
        local rom:ghostRom := Struct.ghostRom(Time.now(), creator, royalty, name, description, imageURI, infoURI, attributeType1, attributeValue1, attributeType2, attributeValue2, attributeType3, attributeValue3, attributeType4, attributeValue4);

        // mint numOfNfts NFT
        while (index < numOfNfts) {
            // mint NFT
            local tokenID:number := NFT.mint(creator, creator, mintTicker, rom, "", editionId);
            // if infuseMultiplier > 0
            if (_infuseMultiplier > 0)
            {
                // local var for infuseAmount
                local infuseAmount:number := _infuseMultiplier * 10 ^ Token.getDecimals(_feesSymbol);
                // infuse NFT
                NFT.infuse(creator, mintTicker, tokenID, _feesSymbol, infuseAmount);
            }
            // if locked content
            if (hasLockedContent)
            {
                // set locked content storage map
                _lockedStorageMap.set(tokenID, lockedContent);
            }
            index := index + 1;
        }

        // if feesMultipler > 0, pay service fees and pay burn fees
        if (_feesMultiplier > 0)
        {
            this.payFees(numOfNfts, creator);
        }
    }

    /// @dev Update the current token contract owner address to another address.
    /// @param newOwner - Address of the new owner - address
    public updateOwner(newOwner:address)
    {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // set new owner
        _addressOwner:= newOwner;
    }

    /// @dev Update the current status of the token contract (paused / active).
    /// @param pause - Status of the contract - bool
    public updatePause(pause:bool)
    {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // set new status
        _contractPaused:= pause;
    }

    /// @dev Update the current fees multiplier.
    /// @param feesMultiplier - Number to use to multiply base fees - number
    public updateFeesMultiplier(feesMultiplier:number)
    {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // check feesMultiplier parameter
        Runtime.expect(feesMultiplier > 0, "invalid number for feesMultiplier, it should be > 0, received " + feesMultiplier);

        // set fees
        _feesMultiplier:= feesMultiplier;
    }

	/// @dev Update the current asset used for fees.
    /// @param feesSymbol - Asset to use to pay fees - string
    public updateFeesSymbol(feesSymbol:string)
    {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // check feesSymbol parameter
		Runtime.expect(Token.exists(feesSymbol), "invalid token for feesSymbol, received " + feesSymbol);

        // check feesSymbol is fungible
        local flags:TokenFlags := Token.getFlags(feesSymbol);
        Runtime.expect(flags.isSet(TokenFlags.Fungible) == true, "invalid fungible flag for " + feesSymbol);

        // set fees
        _feesSymbol:= feesSymbol;
    }

    /// @dev Update the current fees thresholds.
    /// @param feesThresholdIndex - Index of the threshold (1,2 or 3) - number
    /// @param feesThresholdValue - Value of the specific threshold - number
    public updateFeesThresholds(feesThresholdIndex:number, feesThresholdValue:number)
    {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // check feesThresholdIndex parameter
        Runtime.expect(feesThresholdIndex <= 3, "invalid number for feesThresholdIndex, it should be 1,2 or 3, received " + feesThresholdIndex);
        Runtime.expect(feesThresholdIndex > 0, "invalid number for feesThresholdIndex, it should be 1,2 or 3, received " + feesThresholdIndex);

        // check feesThresholdValue parameter
        Runtime.expect(feesThresholdValue > 0, "invalid number for feesThresholdValue, it should be > 0, received " + feesThresholdValue);

        // set fees
        if (feesThresholdIndex == 1)
        {
            _feesThreshold1:= feesThresholdValue;
        }
        if (feesThresholdIndex == 2)
        {
            _feesThreshold2:= feesThresholdValue;
        }
        if (feesThresholdIndex == 3)
        {
            _feesThreshold3:= feesThresholdValue;
        }
    }

	/// @dev Update the current fees address.
    /// @param feesAddress - address used to collect fees - address
    public updateFeesAddress(feesAddress:address)
    {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // set fees
        _feesAddress:= feesAddress;
    }

    /// @dev Update the infuse multiplier.
    /// @param infuseMultiplier - multiplier used for infuse - number
    public updateInfuseMultiplier(infuseMultiplier:number)
    {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // check infuseMultiplier parameter
        Runtime.expect(infuseMultiplier >= 0, "invalid number for infuseMultiplier, it should be >= 0, received " + infuseMultiplier);

        // set infuse multiplier
        _infuseMultiplier := infuseMultiplier;
    }

    /// @dev Mint a specific number of NFT on GhostMarket contract.
    /// @param editionId - ID of the NFT series - number
    /// @param editionMax - Edition Max the NFT series - number
    /// @param editionMode - Edition Mode the NFT series, 1 for duplicate, 2 for unique - number
    /// @param creator - Original owner of the NFT - address
    /// @param royalty - Commission (in %) for the royalties - decimal<2>
    /// @param mintTicker - Ticker token on which to mint the NFT - string
    /// @param numOfNfts - Quantity of NFT to mint - number
    /// @param name - Name of the NFT to mint - string
    /// @param description - Description of the NFT to mint - string
    /// @param imageURI - Image of the NFT - IPFS hash - string
    /// @param attributeType1 - Extended properties of the NFT - string
    /// @param attributeValue1 - Extended properties of the NFT - string
    /// @param attributeType2 - Extended properties of the NFT - string
    /// @param attributeValue2 - Extended properties of the NFT - string
    /// @param attributeType3 - Extended properties of the NFT - string
    /// @param attributeValue3 - Extended properties of the NFT - string
    /// @param attributeType4 - Extended properties of the NFT - string
    /// @param attributeValue4 - Extended properties of the NFT - string
    /// @param hasLockedContent - NFT has locked content - bool
    /// @param lockedContent - NFT locked content hash - string
    public mintToken(editionId:number, editionMax:number, editionMode:number, creator:address, royalty:decimal<2>, mintTicker:string, numOfNfts:number, name:string, description:string, imageURI:string, attributeType1:string, attributeValue1:string, attributeType2:string, attributeValue2:string, attributeType3:string, attributeValue3:string, attributeType4:string, attributeValue4:string, hasLockedContent:bool, lockedContent:string)
    {
        // check if contract is active
        Runtime.expect(this.checkContractPaused() != true, "GhostMarket smart contract is currently paused");

        // check is witness
        Runtime.expect(Runtime.isWitness(creator), "invalid witness");

        // check allow gas dapp transaction fees
        Runtime.expect(Runtime.gasTarget() == _addressContract, "invalid address for dapp transaction fees in AllowGas, it should be " + _addressContract);

        // check editionId parameter
        Runtime.expect(editionId >= 0, "invalid number for editionId, it should be >= 0, received " + editionId);

        // check editionMode parameter
        Runtime.expect(editionMode > 0, "invalid number for editionMode, it should be > 0, received " + editionMode);

        // check mintTicker parameter
        Runtime.expect(Token.exists(mintTicker), "invalid token for mintTicker, received " + mintTicker);
        local flags:TokenFlags := Token.getFlags(mintTicker);
        Runtime.expect(flags.isSet(TokenFlags.Fungible) == false, "invalid fungible flag for " + mintTicker);

        // check if new series and create it
        if (editionId == 0)
        {
            // check editionMax parameter
            Runtime.expect(editionMax >= 0, "invalid number for editionMax, it should be >= 0, received " + editionMax);

            // check name parameter
            Runtime.expect(name.length() >= 3, "invalid char length for name, it should be >= 3, received " + name.length());
            Runtime.expect(name.length() <= 30, "invalid char length for name, it should be <= 30, received " + name.length());

            // check description parameter
            Runtime.expect(description.length() >= 10, "invalid char length for description, it should be >= 10, received " + description.length());
            Runtime.expect(description.length() <= 100, "invalid char length for description, it should be <= 100, received " + description.length());

            // check imageURI parameter
            Runtime.expect(imageURI.length() >= 0, "invalid char length for imageURI, it should be >= 0, received " + imageURI.length());

            // check royalty parameter
            Runtime.expect(royalty >= 0.00 and royalty <= 50.00, "invalid number for royalties, it should be between 0.00 and 50.00");

            // check extended parameters
            if (attributeType1.length() > 0)
            {
                Runtime.expect(attributeType1.length() < 15, "invalid extended attributeType1 length");
            }
            if (attributeValue1.length() > 0)
            {
                Runtime.expect(attributeType1.length() > 0, "invalid extended attributeType1 length");
                Runtime.expect(attributeValue1.length() < 15, "invalid extended attributeValue1 length");
            }
            if (attributeType2.length() > 0)
            {
                Runtime.expect(attributeType2.length() < 15, "invalid extended attributeType2 length");
            }
            if (attributeValue2.length() > 0)
            {
                Runtime.expect(attributeType2.length() > 0, "invalid extended attributeType2 length");
                Runtime.expect(attributeValue2.length() < 15, "invalid extended attributeValue2 length");
            }
            if (attributeType3.length() > 0)
            {
                Runtime.expect(attributeType3.length() < 15, "invalid extended attributeType3 length");
            }
            if (attributeValue3.length() > 0)
            {
                Runtime.expect(attributeType3.length() > 0, "invalid extended attributeType3 length");
                Runtime.expect(attributeValue3.length() < 15, "invalid extended attributeValue3 length");
            }
            if (attributeType4.length() > 0)
            {
                Runtime.expect(attributeType4.length() < 15, "invalid extended attributeType4 length");
            }
            if (attributeValue4.length() > 0)
            {
                Runtime.expect(attributeType4.length() > 0, "invalid extended attributeType4 length");
                Runtime.expect(attributeValue4.length() < 15, "invalid extended attributeValue4 length");
            }

            // check hashLockedContent parameter
            if (hasLockedContent)
            {
                Runtime.expect(lockedContent.length() >= 0, "invalid char length for lockedContent, it should be >= 0, received " + lockedContent.length());
            }
            else
            {
                Runtime.expect(lockedContent.length() == 0, "invalid char length for lockedContent, it should be == 0, received " + lockedContent.length());
            }

            // new series - create series ID
            editionId := UID.generate();

            // new series - create series
            this.createSeries(editionId, editionMax, editionMode, creator, mintTicker);
        }

        // check numOfNfts parameter
        Runtime.expect(numOfNfts > 0, "invalid number for numOfNfts, it should be > 0, received " + numOfNfts);
        Runtime.expect(numOfNfts <= editionMax, "invalid number for numOfNfts, it should be < editionMax, received " + numOfNfts);
        if (editionMode == 2)
        {
            Runtime.expect(numOfNfts == 1, "invalid number for numOfNfts on unique mode series, it should be 1 max, received " + numOfNfts);
        }

        // if fees multiplier > 0, check if enough for transfer fees and burn fees
        if (_feesMultiplier > 0)
        {
            this.checkFees(numOfNfts, creator);
        }

        // start minting nft in nft series
        this.mintSeries(editionId, creator, royalty, mintTicker, numOfNfts, name, description, imageURI, attributeType1, attributeValue1, attributeType2, attributeValue2, attributeType3, attributeValue3, attributeType4, attributeValue4, hasLockedContent, lockedContent);
    }

    /// @dev get locked content of a specific nft series.
    /// @param from - Address querying for content - address
    /// @param nftID - Locked content of a specific NFT - number
    public getLockedContent(from:address, nftID:number):string
    {
        // check is witness and is current owner
        // Runtime.expect(from == OWNEROF(nftID), "invalid owner address, received " + from + " while it should be " + OWNEROF(nftID)); // how to get current owner??
		Runtime.expect(Runtime.isWitness(from), "invalid witness");

        // return content if owner
        if (_lockedStorageMap.has(nftID))
        {
            return _lockedStorageMap.get(nftID);
        }
    }

    /// @dev onUpgrade trigger.
    /// @param from - Address from - address
	trigger onUpgrade(from:address)
    {
        // check is witness and is current owner
        Runtime.expect(from == _addressOwner, "invalid owner address, received " + from + " while it should be " + _addressOwner);
		Runtime.expect(Runtime.isWitness(from), "invalid witness");
        return;
    }

    /// @dev onMint trigger.
    /// @param from - Address from - address
    /// @param from - Address to - address
    /// @param from - Symbol - string
    /// @param from - Amount - number
    trigger onMint(from:address, to:address, symbol:string, amount:number)
    {

    }

}